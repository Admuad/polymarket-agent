use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};
use sqlx::{FromRow, Type};
pub use uuid::Uuid;

/// Core market data types
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Market {
    pub id: Uuid,
    pub condition_id: String,
    pub question: String,
    pub description: String,
    pub category: String,
    pub outcomes: Vec<Outcome>,
    pub created_at: DateTime<Utc>,
    pub updated_at: DateTime<Utc>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Outcome {
    pub id: String,
    pub name: String,
    pub price: f64,
    pub liquidity: f64,
}

/// Order book data
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct OrderBook {
    pub market_id: Uuid,
    pub timestamp: DateTime<Utc>,
    pub bids: Vec<Order>,
    pub asks: Vec<Order>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Order {
    pub outcome_id: String,
    pub price: f64,
    pub size: f64,
}

/// Trade data
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Trade {
    pub id: Uuid,
    pub market_id: Uuid,
    pub outcome_id: String,
    pub price: f64,
    pub size: f64,
    pub side: OrderSide,
    pub timestamp: DateTime<Utc>,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize, Type)]
#[sqlx(type_name = "order_side", rename_all = "lowercase")]
pub enum OrderSide {
    Buy,
    Sell,
}

/// Market price tick
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PriceTick {
    pub market_id: Uuid,
    pub outcome_id: String,
    pub price: f64,
    pub volume_24h: f64,
    pub liquidity: f64,
    pub timestamp: DateTime<Utc>,
}

/// Event types for the event bus
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(tag = "type")]
pub enum MarketEvent {
    OrderBookUpdate(OrderBook),
    Trade(Trade),
    PriceTick(PriceTick),
    MarketCreated(Market),
    MarketResolved { market_id: Uuid, outcome_id: String },
}

impl MarketEvent {
    pub fn market_id(&self) -> Uuid {
        match self {
            MarketEvent::OrderBookUpdate(ob) => ob.market_id,
            MarketEvent::Trade(t) => t.market_id,
            MarketEvent::PriceTick(pt) => pt.market_id,
            MarketEvent::MarketCreated(m) => m.id,
            MarketEvent::MarketResolved { market_id, .. } => *market_id,
        }
    }

    pub fn timestamp(&self) -> DateTime<Utc> {
        match self {
            MarketEvent::OrderBookUpdate(ob) => ob.timestamp,
            MarketEvent::Trade(t) => t.timestamp,
            MarketEvent::PriceTick(pt) => pt.timestamp,
            MarketEvent::MarketCreated(m) => m.created_at,
            MarketEvent::MarketResolved { .. } => Utc::now(),
        }
    }
}

// ============================================================================
// Monitoring & Learning Types (Layer 5)
// ============================================================================

/// Market resolution status
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize, Type)]
#[sqlx(type_name = "resolution_status", rename_all = "lowercase")]
pub enum ResolutionStatus {
    Pending,
    Resolved,
    Disputed,
    Cancelled,
}

/// Market resolution result
#[derive(Debug, Clone, Serialize, Deserialize, FromRow)]
pub struct Resolution {
    pub market_id: Uuid,
    pub outcome_id: String,
    pub status: ResolutionStatus,
    pub resolved_at: Option<DateTime<Utc>>,
    pub resolution_price: Option<f64>, // 1.0 for true, 0.0 for false
}

/// Trade with signal attribution
#[derive(Debug, Clone, Serialize, Deserialize, FromRow)]
pub struct AttributedTrade {
    pub trade_id: Uuid,
    pub market_id: Uuid,
    pub outcome_id: String,
    pub side: OrderSide,
    pub entry_price: f64,
    pub size: f64,
    pub entry_time: DateTime<Utc>,
    pub exit_price: Option<f64>,
    pub exit_time: Option<DateTime<Utc>>,
    pub signal_id: Uuid,
    pub agent_id: Uuid,
    pub strategy_id: String,
    pub pnl: Option<f64>,
    pub pnl_percent: Option<f64>,
}

/// Signal generated by an agent/strategy
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Signal {
    pub id: Uuid,
    pub market_id: Uuid,
    pub outcome_id: String,
    pub predicted_probability: f64,
    pub confidence: f64,
    pub direction: OrderSide,
    pub agent_id: Uuid,
    pub strategy_id: String,
    pub generated_at: DateTime<Utc>,
    pub metadata: serde_json::Value,
}

/// Performance metrics for a strategy/agent
#[derive(Debug, Clone, Serialize, Deserialize, FromRow)]
pub struct PerformanceMetrics {
    pub strategy_id: String,
    pub period_start: DateTime<Utc>,
    pub period_end: DateTime<Utc>,
    pub total_trades: i64,
    pub winning_trades: i64,
    pub losing_trades: i64,
    pub hit_rate: f64,
    pub total_pnl: f64,
    pub roi: f64,
    pub sharpe_ratio: Option<f64>,
    pub max_drawdown: f64,
    pub avg_win: f64,
    pub avg_loss: f64,
    pub profit_factor: f64,
    pub calmar_ratio: Option<f64>,
}

/// Strategy performance summary
#[derive(Debug, Clone, Serialize, Deserialize, FromRow)]
pub struct StrategyPerformance {
    pub strategy_id: String,
    pub total_trades: i64,
    pub total_pnl: f64,
    pub gross_profit: f64,
    pub gross_loss: f64,
    pub avg_return_pct: f64,
}

/// Prediction calibration metrics
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CalibrationMetrics {
    pub strategy_id: String,
    pub period_start: DateTime<Utc>,
    pub period_end: DateTime<Utc>,
    pub brier_score: f64,
    pub log_loss: f64,
    pub calibration_error: f64,
    pub total_predictions: i64,
    pub confidence_buckets: Vec<ConfidenceBucket>,
}

/// Confidence bucket for calibration analysis
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ConfidenceBucket {
    pub min_confidence: f64,
    pub max_confidence: f64,
    pub count: i64,
    pub avg_predicted_prob: f64,
    pub actual_outcome_rate: f64,
    pub calibration_error: f64,
}

/// Drift detection result
#[derive(Debug, Clone, Serialize, Deserialize, FromRow)]
pub struct DriftDetection {
    pub strategy_id: String,
    pub detected_at: DateTime<Utc>,
    pub drift_type: DriftType,
    pub severity: DriftSeverity,
    pub metric_value: f64,
    pub threshold: f64,
    pub description: String,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize, Type)]
#[sqlx(type_name = "drift_type", rename_all = "snake_case")]
pub enum DriftType {
    PerformanceDrift,
    PredictionDrift,
    MarketStructureDrift,
    VolumeDrift,
    CalibrationDrift,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize, Type)]
#[sqlx(type_name = "drift_severity", rename_all = "lowercase")]
pub enum DriftSeverity {
    Low,
    Medium,
    High,
    Critical,
}

impl std::fmt::Display for DriftSeverity {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            DriftSeverity::Low => write!(f, "Low"),
            DriftSeverity::Medium => write!(f, "Medium"),
            DriftSeverity::High => write!(f, "High"),
            DriftSeverity::Critical => write!(f, "Critical"),
        }
    }
}

/// A/B test configuration and results
#[derive(Debug, Clone, Serialize, Deserialize, FromRow)]
pub struct AbTest {
    pub id: Uuid,
    pub name: String,
    pub strategy_a: String,
    pub strategy_b: String,
    pub start_time: DateTime<Utc>,
    pub end_time: Option<DateTime<Utc>>,
    pub status: AbTestStatus,
    pub allocation_ratio: f64, // 0.5 = 50/50 split
    pub min_sample_size: i64,
    pub statistical_significance: f64, // 0.95 for 95% confidence
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize, Type)]
#[sqlx(type_name = "ab_test_status", rename_all = "lowercase")]
pub enum AbTestStatus {
    Running,
    Paused,
    Completed,
    Inconclusive,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AbTestResult {
    pub test_id: Uuid,
    pub strategy_a_metrics: PerformanceMetrics,
    pub strategy_b_metrics: PerformanceMetrics,
    pub winner: Option<String>, // "A", "B", or null
    pub confidence: Option<f64>,
    pub p_value: Option<f64>,
    pub recommendation: String,
}

/// Shadow mode trade (paper trading)
#[derive(Debug, Clone, Serialize, Deserialize, FromRow)]
pub struct ShadowTrade {
    pub id: Uuid,
    pub trade_id: Option<Uuid>, // Real trade ID if executed
    pub market_id: Uuid,
    pub outcome_id: String,
    pub side: OrderSide,
    pub price: f64,
    pub size: f64,
    pub timestamp: DateTime<Utc>,
    pub strategy_id: String,
    pub hypothetical_pnl: Option<f64>,
    pub would_have_won: Option<bool>,
}
