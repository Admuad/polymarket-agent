//! Agent Communication Bus
//!
//! Provides a publish/subscribe messaging system for agent-to-agent communication.
//! Currently uses tokio channels, with future support for Redis Streams.

use anyhow::Result;
use dashmap::DashMap;
use serde::{Deserialize, Serialize};
use std::sync::Arc;
use tokio::sync::{broadcast, mpsc, RwLock};
use uuid::Uuid;
use chrono::{DateTime, Utc};

/// Priority levels for messages
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Serialize, Deserialize)]
pub enum MessagePriority {
    Low = 0,
    Normal = 1,
    High = 2,
    Critical = 3,
}

/// Message types in the agent bus
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(tag = "type")]
pub enum AgentMessage {
    /// Signal generated by an agent (e.g., sentiment signal)
    Signal {
        agent_id: String,
        market_id: Uuid,
        signal_data: serde_json::Value,
        confidence: f64,
        timestamp: DateTime<Utc>,
    },

    /// Request for data from another agent
    DataRequest {
        request_id: String,
        requester_id: String,
        target_agent: String,
        market_id: Uuid,
        query: serde_json::Value,
    },

    /// Response to a data request
    DataResponse {
        request_id: String,
        responder_id: String,
        data: Option<serde_json::Value>,
        error: Option<String>,
    },

    /// Control/administrative message
    Control {
        target: Option<String>, // None means broadcast to all
        command: serde_json::Value,
    },

    /// Health/status update
    StatusUpdate {
        agent_id: String,
        status: serde_json::Value,
        timestamp: DateTime<Utc>,
    },
}

impl AgentMessage {
    pub fn priority(&self) -> MessagePriority {
        match self {
            AgentMessage::Control { .. } => MessagePriority::Critical,
            AgentMessage::DataRequest { .. } => MessagePriority::High,
            AgentMessage::DataResponse { .. } => MessagePriority::High,
            AgentMessage::Signal { confidence, .. } => {
                if *confidence > 0.8 {
                    MessagePriority::High
                } else if *confidence > 0.5 {
                    MessagePriority::Normal
                } else {
                    MessagePriority::Low
                }
            }
            AgentMessage::StatusUpdate { .. } => MessagePriority::Low,
        }
    }
}

/// Configuration for the agent bus
#[derive(Debug, Clone)]
pub struct AgentBusConfig {
    /// Channel capacity for unicast messages
    pub channel_capacity: usize,
    /// Capacity for broadcast channels
    pub broadcast_capacity: usize,
    /// Enable message persistence (future: Redis)
    pub enable_persistence: bool,
    /// Redis connection string (future)
    pub redis_url: Option<String>,
}

impl Default for AgentBusConfig {
    fn default() -> Self {
        Self {
            channel_capacity: 1000,
            broadcast_capacity: 100,
            enable_persistence: false,
            redis_url: None,
        }
    }
}

/// Agent communication bus
///
/// Supports both unicast (point-to-point) and broadcast (pub/sub) messaging.
/// Can be extended to use Redis Streams for distributed scenarios.
pub struct AgentBus {
    config: AgentBusConfig,

    // Topic-based broadcast channels
    broadcasts: Arc<RwLock<DashMap<String, broadcast::Sender<AgentMessage>>>>,

    // Point-to-point channels (agent_id -> mpsc sender)
    unicast: Arc<DashMap<String, mpsc::Sender<AgentMessage>>>,

    // Global broadcast for all messages (useful for logging/debugging)
    global_broadcast: broadcast::Sender<AgentMessage>,
}

impl AgentBus {
    /// Create a new agent bus
    pub async fn new(config: AgentBusConfig) -> Result<Self> {
        let (global_tx, _) = broadcast::channel(config.broadcast_capacity);

        Ok(Self {
            config,
            broadcasts: Arc::new(RwLock::new(DashMap::new())),
            unicast: Arc::new(DashMap::new()),
            global_broadcast: global_tx,
        })
    }

    /// Register an agent and get its receiver
    pub async fn register_agent(&self, agent_id: &str) -> Result<AgentBusHandle> {
        // Create unicast channel for this agent
        let (tx, rx) = mpsc::channel(self.config.channel_capacity);
        self.unicast.insert(agent_id.to_string(), tx.clone());

        // Subscribe to global broadcast
        let global_rx = self.global_broadcast.subscribe();

        Ok(AgentBusHandle {
            agent_id: agent_id.to_string(),
            tx,
            rx,
            global_rx,
            broadcasts: Arc::clone(&self.broadcasts),
            unicast: Arc::clone(&self.unicast),
            global_tx: self.global_broadcast.clone(),
        })
    }

    /// Unregister an agent
    pub fn unregister_agent(&self, agent_id: &str) {
        self.unicast.remove(agent_id);
    }

    /// Subscribe to a topic (returns a receiver)
    pub async fn subscribe(&self, topic: &str) -> Result<broadcast::Receiver<AgentMessage>> {
        // First try to get existing topic
        let rx_opt = {
            let broadcasts = self.broadcasts.read().await;
            broadcasts.get(topic).map(|tx| tx.subscribe())
        };

        if let Some(rx) = rx_opt {
            return Ok(rx);
        }

        // Create new topic
        let (tx, rx) = broadcast::channel(self.config.broadcast_capacity);
        self.broadcasts.write().await.insert(topic.to_string(), tx);
        Ok(rx)
    }

    /// Subscribe multiple agents to a topic
    pub async fn subscribe_many(&self, topic: &str, count: usize) -> Result<Vec<broadcast::Receiver<AgentMessage>>> {
        let mut receivers = Vec::new();
        for _ in 0..count {
            receivers.push(self.subscribe(topic).await?);
        }
        Ok(receivers)
    }
}

/// Handle for an agent to send and receive messages
pub struct AgentBusHandle {
    agent_id: String,
    tx: mpsc::Sender<AgentMessage>,
    rx: mpsc::Receiver<AgentMessage>,
    global_rx: broadcast::Receiver<AgentMessage>,
    broadcasts: Arc<RwLock<DashMap<String, broadcast::Sender<AgentMessage>>>>,
    unicast: Arc<DashMap<String, mpsc::Sender<AgentMessage>>>,
    global_tx: broadcast::Sender<AgentMessage>,
}

impl AgentBusHandle {
    /// Get the agent's ID
    pub fn agent_id(&self) -> &str {
        &self.agent_id
    }

    /// Send a message to a specific agent
    pub async fn send_to(&self, target_agent: &str, msg: AgentMessage) -> Result<()> {
        if let Some(tx) = self.unicast.get(target_agent) {
            tx.send(msg).await?;
            Ok(())
        } else {
            anyhow::bail!("Target agent '{}' not found", target_agent);
        }
    }

    /// Broadcast a message to a topic
    pub async fn publish(&self, topic: &str, msg: AgentMessage) -> Result<()> {
        let tx_opt = {
            let broadcasts = self.broadcasts.read().await;
            broadcasts.get(topic).map(|tx| tx.clone())
        };

        if let Some(tx) = tx_opt {
            let _ = tx.send(msg.clone());
        }

        // Also send to global broadcast
        let _ = self.global_tx.send(msg);

        Ok(())
    }

    /// Send a request and wait for a response
    pub async fn request(&self, target_agent: &str, request: AgentMessage, timeout_ms: u64) -> Result<AgentMessage> {
        let _request_id = Uuid::new_v4().to_string();

        // Create a one-shot channel for the response
        let (_resp_tx, mut resp_rx) = mpsc::channel(1);

        // Store the response channel (in a real implementation, this would be in a registry)
        // For now, we'll use a simpler approach with a dedicated response topic

        // Send the request
        self.send_to(target_agent, request).await?;

        // Wait for response
        let timeout = tokio::time::Duration::from_millis(timeout_ms);
        tokio::select! {
            response = resp_rx.recv() => {
                match response {
                    Some(msg) => Ok(msg),
                    None => anyhow::bail!("Response channel closed"),
                }
            }
            _ = tokio::time::sleep(timeout) => {
                anyhow::bail!("Request timeout after {}ms", timeout_ms)
            }
        }
    }

    /// Receive a message sent to this agent
    pub async fn recv(&mut self) -> Option<AgentMessage> {
        self.rx.recv().await
    }

    /// Receive any message from the global broadcast
    pub async fn recv_global(&mut self) -> Option<AgentMessage> {
        match self.global_rx.recv().await {
            Ok(msg) => Some(msg),
            Err(_) => None,
        }
    }

    /// Try to receive without blocking
    pub fn try_recv(&mut self) -> Result<AgentMessage> {
        self.rx.try_recv().map_err(|e| anyhow::anyhow!("{}", e))
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[tokio::test]
    async fn test_bus_register() {
        let bus = AgentBus::new(AgentBusConfig::default()).await.unwrap();
        let handle = bus.register_agent("agent1").await.unwrap();
        assert_eq!(handle.agent_id(), "agent1");
    }

    #[tokio::test]
    async fn test_pub_sub() {
        let bus = AgentBus::new(AgentBusConfig::default()).await.unwrap();
        let mut handle1 = bus.register_agent("agent1").await.unwrap();
        let mut handle2 = bus.register_agent("agent2").await.unwrap();

        // Subscribe to a topic
        let mut rx = bus.subscribe("signals").await.unwrap();

        // Publish to the topic
        let msg = AgentMessage::Control {
            target: None,
            command: serde_json::json!({"test": true}),
        };
        handle1.publish("signals", msg).await.unwrap();

        // Receive
        let received = rx.recv().await.unwrap();
        assert!(matches!(received, AgentMessage::Control { .. }));
    }

    #[tokio::test]
    async fn test_message_priority() {
        let signal = AgentMessage::Signal {
            agent_id: "test".to_string(),
            market_id: Uuid::new_v4(),
            signal_data: serde_json::json!({}),
            confidence: 0.9,
            timestamp: Utc::now(),
        };
        assert_eq!(signal.priority(), MessagePriority::High);
    }
}
